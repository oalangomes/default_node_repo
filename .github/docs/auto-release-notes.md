# üìù Auto Release Notes Workflow

Este workflow automatiza a gera√ß√£o de **notas de vers√£o (release notes)** no GitHub com base em Pull Requests ou commits, facilitando a rastreabilidade das mudan√ßas em cada vers√£o publicada.

---

## üìÑ Workflow YAML

```yaml
name: üìù Auto Release Notes Generator
on:
  push:
    branches:
      - master
permissions:
  contents: write
  pull-requests: read
jobs:
  generate-release:
    runs-on: ubuntu-latest
    steps:
      - name: üìÇ Checkout do c√≥digo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîß Configura git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: üìä Detecta vers√£o atual e gera pr√≥xima
        id: version
        run: |
          # Cria pasta de release notes se n√£o existir
          mkdir -p release-notes
          
          # Detecta a vers√£o atual do README (se existir)
          if [ -f README.md ] && grep -q '\[V[0-9]' README.md; then
            CURRENT_VERSION=$(grep -oP '\[V\K[0-9]+\.[0-9]+' README.md | head -1)
            echo "üìç Vers√£o atual encontrada: V$CURRENT_VERSION"
            
            # Incrementa a vers√£o (formato X.YY)
            MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
            MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
            MINOR=$((MINOR + 1))
            
            # Se minor >= 100, incrementa major e zera minor
            if [ $MINOR -ge 100 ]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
            fi
            
            NEW_VERSION=$(printf "%02d.%02d" $MAJOR $MINOR)
          else
            echo "üìç Primeira vers√£o, iniciando com V01.00"
            NEW_VERSION="01.00"
          fi
          
          echo "üéØ Nova vers√£o: V$NEW_VERSION"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "version_tag=V$NEW_VERSION" >> "$GITHUB_OUTPUT"
      
      - name: üîç Encontra PR relacionado ao merge
        id: find_pr
        run: |
          # Busca o PR que foi mergeado neste push
          COMMIT_SHA="${{ github.sha }}"
          MERGE_COMMIT_MESSAGE=$(git log --format=%s -n 1 $COMMIT_SHA)
          
          echo "üìù Mensagem do commit: $MERGE_COMMIT_MESSAGE"
          
          # Extrai n√∫mero do PR da mensagem de merge (formato: "Merge pull request #123 from...")
          if [[ "$MERGE_COMMIT_MESSAGE" =~ Merge\ pull\ request\ \#([0-9]+) ]]; then
            PR_NUMBER="${BASH_REMATCH[1]}"
            echo "üîó PR encontrado: #$PR_NUMBER"
            echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
            echo "pr_link=https://github.com/${{ github.repository }}/pull/$PR_NUMBER" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùì Nenhum PR encontrado no merge commit"
            echo "pr_number=N/A" >> "$GITHUB_OUTPUT"
            echo "pr_link=Direct push" >> "$GITHUB_OUTPUT"
          fi
      
      - name: üìã Gera changelog desde √∫ltimo release
        id: changelog
        run: |
          # Encontra o √∫ltimo commit de release notes
          LAST_RELEASE_COMMIT=$(git log --grep="üìù Release V[0-9]" --format="%H" -n 1 || echo "")
          
          if [ -n "$LAST_RELEASE_COMMIT" ]; then
            echo "üìç √öltimo release: $LAST_RELEASE_COMMIT"
          CHANGELOG=$(git log $LAST_RELEASE_COMMIT..HEAD --pretty=format:"- %s (%h)" --no-merges | grep -v "üìù Release V[0-9]" | awk '!seen[$0]++' | head -50)
          else
            echo "üìç Primeiro release, usando √∫ltimos 20 commits"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -n 20)
          fi
          
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="- Atualiza√ß√µes menores e corre√ß√µes"
          fi
          
          echo "CHANGELOG<<EOF" >> $GITHUB_ENV
          echo "$CHANGELOG" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          # Tamb√©m gera um resumo mais limpo
          CLEAN_CHANGELOG=$(echo "$CHANGELOG" | grep -v "ü¶ñ Atualiza badge" | grep -v "Merge branch" | awk '!seen[$0]++' | head -10)
          echo "CLEAN_CHANGELOG<<EOF" >> $GITHUB_ENV
          echo "$CLEAN_CHANGELOG" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      
      - name: üìù Cria arquivo de release notes
        run: |
          VERSION="${{ steps.version.outputs.version_tag }}"
          TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
          DATE_ONLY=$(date '+%Y-%m-%d')
          
          if [ "${{ steps.find_pr.outputs.pr_number }}" = "N/A" ]; then
            PR_MARKDOWN="Direct push"
          else
            PR_MARKDOWN="[#${{ steps.find_pr.outputs.pr_number }}](${{ steps.find_pr.outputs.pr_link }})"
          fi

          cat > "release-notes/release-$VERSION.md" <<EOL
          # Release ${{ steps.version.outputs.version_tag }}

          **üìÖ Data do Release**: $DATE_ONLY
          **üîó Pull Request**: $PR_MARKDOWN
          **üìù Commit**: [\`${{ github.sha }}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          
          ## üöÄ Principais Mudan√ßas
          
          ${{ env.CLEAN_CHANGELOG }}
          
          ## üìã Changelog Completo
          
          ${{ env.CHANGELOG }}
          
          ## üìä Estat√≠sticas
          
          - **Commits inclu√≠dos**: $(echo "${{ env.CHANGELOG }}" | wc -l)
          - **Gerado automaticamente**: $TIMESTAMP
          
          ---
          
          **üîÑ Processo de Release**
          1. ‚úÖ Testes passaram na branch \`main\`
          2. ‚úÖ Cobertura de c√≥digo validada
          3. ‚úÖ Merge aprovado para \`master\`
          4. ‚úÖ Release notes geradas automaticamente
          
          **‚¨ÖÔ∏è [Voltar para vers√µes anteriores](../README.md#-releases)**
          EOL
          
          echo "‚úÖ Release notes criadas: release-notes/release-$VERSION.md"
      
      - name: üîÑ Atualiza README.md
        run: |
          VERSION="${{ steps.version.outputs.version_tag }}"
          DATE_ONLY=$(date '+%d/%m/%Y')
          PR_INFO="${{ steps.find_pr.outputs.pr_number }}"
          PR_LINK="${{ steps.find_pr.outputs.pr_link }}"

          # Garante valor num√©rico antes de usar no markdown
          if printf '%s' "$PR_INFO" | grep -Eq '^[0-9]+$'; then
            PR_MARKDOWN="[#${PR_INFO}]($PR_LINK)"
          else
            PR_MARKDOWN="Direct push"
          fi
          
          # Cria backup do README
          cp README.md README.md.backup
          
          # Verifica se j√° existe se√ß√£o de releases
          if ! grep -q "## üè∑Ô∏è Releases" README.md; then
            echo "üìù Adicionando se√ß√£o de releases no README.md"
            
            # Adiciona a se√ß√£o antes da se√ß√£o "Contribuindo"
            if grep -q "## ü§ù Contribuindo" README.md; then
              # Insere antes da se√ß√£o "Contribuindo"
              sed -i '/## ü§ù Contribuindo/i\\n## üè∑Ô∏è Releases\n\n| Release | Data | Pull Request |\n|---------|------|--------------|' README.md
            else
              # Adiciona no final se n√£o encontrar a se√ß√£o "Contribuindo"
              cat >> README.md << 'EOL'
          
          ## üè∑Ô∏è Releases
          
          | Release | Data | Pull Request |
          |---------|------|--------------|
          EOL
            fi
          fi
          
          # Adiciona nova vers√£o no topo da tabela
          NEW_ROW="| [$VERSION](release-notes/release-$VERSION.md) | $DATE_ONLY | $PR_MARKDOWN |"

          # Remove linha existente da mesma vers√£o
          # Remove somente linhas da tabela que comecem com a vers√£o atual
          # Ignora apenas a coluna da vers√£o exata
          grep -v "^| \[$VERSION\] |" README.md > README.md.tmp && mv README.md.tmp README.md
          
          # Encontra a linha da tabela e adiciona a nova vers√£o
          awk -v new_row="$NEW_ROW" '
          /\| Release \| Data \| Pull Request \|/ {
            print $0
            getline
            print $0
            print new_row
            next
          }
          { print }' README.md > README.md.tmp && mv README.md.tmp README.md
          
          echo "‚úÖ README.md atualizado com vers√£o $VERSION"
      
      - name: üîç Verifica mudan√ßas
        id: check_changes
        run: |
          git add .
          if git diff --staged --quiet; then
            echo "üìù Nenhuma mudan√ßa detectada"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "‚úÖ Mudan√ßas detectadas"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            
            echo "üìã Arquivos modificados:"
            git diff --staged --name-only
          fi
      
      - name: üíæ Commit das mudan√ßas
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version_tag }}"
          git commit -m "üìù Release $VERSION

          üéØ Nova vers√£o: $VERSION
          üîó PR: #${{ steps.find_pr.outputs.pr_number }}
          üìÖ Data: $(date '+%Y-%m-%d')
          
          Mudan√ßas inclu√≠das:
          ${{ env.CLEAN_CHANGELOG }}
          
          ü§ñ Release notes geradas automaticamente"
          
          git push origin master
          echo "‚úÖ Commit de release enviado"
      
      - name: üè∑Ô∏è Cria tag de vers√£o
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version_tag }}"
          git tag -a "$VERSION" -m "Release $VERSION

          ${{ env.CLEAN_CHANGELOG }}"
          
          git push origin "$VERSION"
          echo "‚úÖ Tag $VERSION criada e enviada"
      
      - name: üì¢ Resumo da execu√ß√£o
        if: always()
        run: |
          echo "## üìù Resumo do Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Nova Vers√£o**: ${{ steps.version.outputs.version_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR Relacionado**: #${{ steps.find_pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Arquivo**: release-notes/release-${{ steps.version.outputs.version_tag }}.md" >> $GITHUB_STEP_SUMMARY
          echo "- **README Atualizado**: ${{ steps.check_changes.outputs.has_changes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Data**: $(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_changes.outputs.has_changes }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üéâ Release ${{ steps.version.outputs.version_tag }} gerada com sucesso!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üìã Principais mudan√ßas:**" >> $GITHUB_STEP_SUMMARY
            echo "${{ env.CLEAN_CHANGELOG }}" >> $GITHUB_STEP_SUMMARY
          fi

```

---

## üöÄ O que ele faz

- Monitora merges ou tags em branches espec√≠ficas (geralmente `main` ou `master`)
- Gera notas de vers√£o automaticamente no formato Markdown
- Pode criar um novo Release (GitHub Release) com changelog baseado em PRs ou mensagens de commit
- Automatiza parte do ciclo de versionamento e entrega cont√≠nua

---

## üéØ Usos comuns

- Publica√ß√£o automatizada de changelogs
- CI/CD com releases documentados
- Projetos que seguem [Conventional Commits](https://www.conventionalcommits.org/)
- Integra√ß√£o com `release-please`, `semantic-release` ou GitHub CLI

---

## üß© Requisitos

- Token do GitHub (`GITHUB_TOKEN` ou `GH_TOKEN`) com permiss√£o para criar releases
- Configura√ß√£o m√≠nima de branch principal e estrutura de PRs (ou uso de etiquetas convencionais)

---

## üí° Boas pr√°ticas

- Escreva t√≠tulos de PR e commits descritivos
- Use prefixos como `feat:`, `fix:`, `chore:` para ajudar na classifica√ß√£o autom√°tica
- Inclua `BREAKING CHANGE:` no corpo se necess√°rio

---

## üì¶ Resultado

- Release criado automaticamente em [Releases do GitHub](https://github.com/SEU_REPO/releases)
- Com conte√∫do claro sobre:
  - Novas funcionalidades
  - Corre√ß√µes de bugs
  - Altera√ß√µes n√£o compat√≠veis

---

## üß™ Teste e preview

Se o workflow usa `workflow_dispatch`, voc√™ pode test√°-lo manualmente:
1. V√° na aba **Actions**
2. Selecione o workflow
3. Clique em **Run workflow**

---

## üõ°Ô∏è Seguran√ßa

- Evite publicar releases autom√°ticos de branches inst√°veis
- Combine com valida√ß√µes CI (testes/lint) antes do release
- Verifique se tokens est√£o corretamente escopados

---

## ‚úÖ Conclus√£o

Esse workflow elimina a necessidade de gerar changelogs manuais, aumenta a transpar√™ncia do desenvolvimento e facilita a entrega cont√≠nua com documenta√ß√£o embutida.

